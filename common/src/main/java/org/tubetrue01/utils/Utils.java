package org.tubetrue01.utils;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * Created by IntelliJ IDEA.
 * User : Pengfei Zhang
 * Mail : Tubetrue01@gmail.com
 * Date : 2020/5/27
 * Time : 4:52 下午
 * Description :
 */
@Log4j2
@NoArgsConstructor(access = AccessLevel.PRIVATE)
@SuppressWarnings("all")
public class Utils {
    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    public static class IdUtils {
        // Sequence within milliseconds (0~4095)
        private volatile static long sequence = 0L;

        // The time the last time the ID was generated
        private volatile static long lastTimestamp = -1L;

        /**
         * @return Generate a unique identification number
         */
        public static long generateId() {
            var currentTime = currentTime();

            // If it is generated at the same time, the sequence in milliseconds is performed.
            // The number of bits in the id
            var sequenceBits = 12L;

            /*
             * If the current time is less than the currentTime generated by the previous ID, it indicates that the system clock should be thrown abnormally at this time.
             */
            synchronized (IdUtils.class) {

                if (currentTime < lastTimestamp) {
                    throw new RuntimeException(String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - currentTime));
                }

                if (lastTimestamp == currentTime) {
                    // The mask of the generated sequence, here is 4095 (0b111111111111=0xfff=4095)
                    var sequenceMask = ~(-1L << sequenceBits);
                    sequence = (sequence + 1) & sequenceMask;
                    // Sequence overflow in milliseconds
                    if (sequence == 0) {
                        // Block to the next millisecond and get a new timestamp
                        currentTime = tilNextMillis(lastTimestamp);
                    }
                }
                // Timestamp changed, sequence reset in milliseconds
                else {
                    sequence = 0L;
                }

                // The time the last time the ID was generated
                lastTimestamp = currentTime;
            }

            // Shift and combine to form a 64-bit ID by OR operation
            /* Start time stamp (2019-09-17) */
            var startTimestamp = 1568713735268L;
            // The number of bits in the machine id
            var workerIdBits = 5L;
            var dataCenterIdShift = sequenceBits + workerIdBits;
            // The number of digits in the data center id
            var dataCenterIdBits = 5L;
            var timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits;
            // Data Center ID (0~31)
            var dataCenterId = 0;
            // Working machine ID (0~31)
            var workerId = 0;
            return ((currentTime - startTimestamp) << timestampLeftShift) | (dataCenterId << dataCenterIdShift) | (workerId << sequenceBits) | sequence;
        }

        /**
         * Block until the next millisecond until a new timestamp is obtained
         *
         * @param lastTimestamp The time the last time the ID was generated
         * @return Current timestamp
         */
        private static long tilNextMillis(long lastTimestamp) {
            var timestamp = currentTime();
            while (timestamp <= lastTimestamp) {
                timestamp = currentTime();
            }
            return timestamp;
        }

        /**
         * Returns the current time in milliseconds
         *
         * @return Current time (ms)
         */
        private static long currentTime() {
            return System.currentTimeMillis();
        }

    }

    @Component
    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    public static class RedisUtils {

        private static RedisTemplate<String, Object> redisTemplate;

        @Autowired
        private void setRedisTemplate(RedisTemplate<String, Object> redisTemplate) {
            RedisUtils.redisTemplate = redisTemplate;
        }

        /**
         * @param duration Exist time in redis and the unit is milliseconds
         */
        public static void set(String key, Object object, Long duration) {
            redisTemplate.opsForValue().set(key, object, duration, TimeUnit.SECONDS);
        }

        public static void set(String key, Object object) {
            redisTemplate.opsForValue().set(key, object);
        }

        public static Object get(String key) {
            return redisTemplate.opsForValue().get(key);
        }

        public static void delete(String key) {
            redisTemplate.delete(key);
        }
    }

    // A util for the json
    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    public static class JSONUtils {
        private final static ObjectMapper objectMapper = new ObjectMapper();

        public static String objectToJson(Object obj) {
            try {
                return objectMapper.writeValueAsString(obj);
            } catch (JsonProcessingException e) {
                log.error("-==objectToJson发生异常！==-", e);

            }
            return null;
        }

        public static <T> Map<String, T> jsonToMap(String jsonString) {
            var mapper = new ObjectMapper();
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
            try {
                return mapper.readValue(jsonString, Map.class);
            } catch (IOException e) {
                log.error("-==jsonToMap发生异常！==-", e);
            }
            return null;
        }

        public static <T> T jsonToObject(String jsonStr, Class<T> clazz) {
            objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);
            try {
                return objectMapper.readValue(jsonStr, clazz);
            } catch (IOException e) {
                log.error("-==jsonToObject发生异常！==-", e);
            }
            return null;
        }

        public static <T> List<T> jsonToList(String jsonArrayStr, Class<T> clazz) {

            var javaType = getCollectionType(ArrayList.class, clazz);
            List<T> lst = null;
            try {
                lst = (List<T>) objectMapper.readValue(jsonArrayStr, javaType);
            } catch (IOException e) {
                e.printStackTrace();
            }
            return lst;
        }

        private static JavaType getCollectionType(Class<?> collectionClass, Class<?>... elementClasses) {
            return objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClasses);
        }
    }

    @Log4j2
    @Component
    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    // FIXME Optimized it
    public static class JwtUtils {
        private static final String CLAIM_KEY_MEMBER = "sub";
        private static final String CLAIM_KEY_CREATED = "created";
        private static final String SECRET = "memberSecret";
        private static final Long EXPIRATION = 1000 * 60L;
        private static final String MEMBER_TOKEN = "member_token";

        // According to the token responsible for generating JWT
        private String generateToken(Map<String, Object> claims) {
            return Jwts.builder()
                    .setClaims(claims)
//                .setExpiration(generateExpirationDate())
                    .signWith(SignatureAlgorithm.HS512, SECRET)
                    .compact();
        }

        // Get the load in JWT from the token
        private Claims getClaimsFromToken(String token) {
            Claims claims = null;
            try {
                claims = Jwts.parser()
                        .setSigningKey(SECRET)
                        .parseClaimsJws(token)
                        .getBody();
            } catch (Exception e) {
                log.error("JWT格式验证失败:{}", token);
            }
            return claims;
        }

        // Generate token expiration time
        private Date generateExpirationDate() {
            return new Date(System.currentTimeMillis() + EXPIRATION);
        }

        // Get login user from token
        public String getUserNameFromToken(String token) {
            String username;
            try {
                var claims = getClaimsFromToken(token);
                username = claims.getSubject();
            } catch (Exception e) {
                username = null;
            }
            return username;
        }

        /**
         * Verify that the token is still valid
         *
         * @param token from client
         * @param key
         */
        public boolean validateToken(String token, String key) {
            var username = getUserNameFromToken(token);
            return username.equals(key) && !isTokenExpired(token);
        }

        // Determine whether the token has expired
        private boolean isTokenExpired(String token) {
            var expiredDate = getExpiredDateFromToken(token);
            //return expiredDate.before(new Date());
            return false;
        }

        // Get expiration time from token
        private Date getExpiredDateFromToken(String token) {
            var claims = getClaimsFromToken(token);
            return claims.getExpiration();
        }

        // Generate token based on user information
        public String generateToken(String key) {
            Map<String, Object> claims = new HashMap<>();
            claims.put(CLAIM_KEY_MEMBER, key);
            claims.put(CLAIM_KEY_CREATED, new Date());
            return generateToken(claims);
        }

        // Determine whether the token can be refreshed
        public boolean canRefresh(String token) {
            return !isTokenExpired(token);
        }

        // Refresh token
        public String refreshToken(String token) {
            Claims claims = getClaimsFromToken(token);
            claims.put(CLAIM_KEY_CREATED, new Date());
            return generateToken(claims);
        }

    }

}
